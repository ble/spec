{
  "name": "FlyWeb",
  "tagline": "Web API specification for enabling web pages to publish local-area servers",
  "body": "# Introduction\r\n\r\nThis specification aims to allow web applications to connect with and\r\ncommunicate to each other over local-area transport protocols. In particular,\r\nthis specification aims to bring the web's client/server application model to\r\ninter-device communication. The web's application architecture enables an\r\napplication running on a server to dynamically and incrementally send\r\napplication state and logic to an intermittently connected client. This model\r\nenables a powerful multi-homed application architecture.\r\n\r\nIn contrast to this power, the web architecture is also constrained.  A server\r\nmust reside on a TCP-based network and must have an IP address. A client can\r\nonly identify a server via a URL it is given. Only clients may initiate\r\nconnections to servers; servers cannot identify and initiate connections to\r\nclients. A client/server session must be established over a TCP socket and no\r\nother underlying transport protocol may be used.\r\n\r\nThis specification aims to lift the above restrictions and allow the web's\r\napplication architecture to work between devices which are proximally located.\r\nWith FlyWeb, both web clients and servers may advertise themselves for\r\nlocal-area consumption over local-area transport protocols such as Bluetooth,\r\nWi-Fi Direct or over a wired/wireless LAN. Clients may discover and connect to\r\nservers and vice-versa, servers may discover and connect to locally available\r\nweb clients.\r\n\r\nIn addition, FlyWeb aims to introduce a web API to allow web pages to host a\r\n*server endpoint*. This mechanism is designed as a way to enable cross-device\r\ncommunication using no additional infrastructure aside from web browsers.\r\n\r\n# Conformance\r\n\r\nTODO\r\n\r\n# Dependencies\r\n\r\nTODO\r\n\r\n# Terminology\r\n\r\nThis web API is structured around a process for establishing a web session\r\nbetween two computational endpoints where one endpoint serves as a web client\r\nand the other as a web server.\r\n\r\n### Client endpoint\r\n\r\nA *client endpoint* is a device or program on that device which plays the role\r\nof a web client in a FlyWeb session. This endpoint is able to receive and\r\nexecute web applications written using web technologies such as HTML, JavaScript\r\nand CSS. The canonical *client endpoint* is a web browser.\r\n\r\n### Server endpoint\r\n\r\nA *server endpoint* is a device or program on that device which plays the role\r\nof a web server in a FlyWeb session. This endpoint is able to serve web\r\napplications using the HTTP protocol.\r\n\r\nTo establish a FlyWeb session, the *client endpoint* performs a local-area\r\ndiscovery (at the direction of the user) over supported underlying transports\r\n(e.g. mDNS over Wi-Fi). The discovery reveals the presence of any local-area\r\n*server endpoints* which are presented to the user. The user then selects\r\na *server endpoint* to connect to, at which point the client performs whatever\r\ntransport-specific steps are required to set up a web session with the server.\r\nIt then navigates to a page on the server which establishes an application\r\nsession between the user on the *client endpoint* and the service exposed by\r\nthe *server endpoint*.\r\n\r\n# Security and privacy considerations\r\n\r\nThe web API defined in this specification can be used to find and connect to\r\ndevices and services near the user. This specification uses two mechanisms\r\nto ensure that services are not inadvertently exposed to potentially\r\nmalicious code executing on web pages.\r\n\r\nFirstly, a *server endpoint* advertises its services with explicit metadata\r\nthat indicates its willingness to serve as a FlyWeb *server endpoint*. Other\r\nnon-FlyWeb services which are advertised using similar mechanisms cannot thus\r\nbe mistaken for a FlyWeb service.\r\n\r\nSecondly, an endpoint may force a pairing protocol at the point of session\r\nestablishment. This protocol may take various forms including entering a\r\nsecret code, scanning a QR code displayed on a screen, or a synchronized\r\nbutton press. These pairing protocols are similar to Bluetooth device pairing\r\nprotocols and are already familiar to users.\r\n\r\n# Advertising a server\r\n\r\nFlyWeb allows web pages to expose a *server endpoint* using a web API:\r\n\r\n```language-webidl\r\ninterface FlyWebPublishingAPI {\r\n  Promise<FlyWebPublishedServer> publishServer(DOMString name,\r\n                                               FlyWebPublishOptions options);\r\n};\r\n\r\ndictionary FlyWebPublishOptions {\r\n  DOMString? uiUrl = null; // URL to user interface. Can be different server. Makes\r\n                           // endpoint show up in browser's \"local services\" UI.\r\n                           // If relative, resolves against the root of the server.\r\n};\r\n```\r\n\r\n*Do we need something to hide server from discovery?*\r\n\r\n*Rather than have a separate `uiUrl` property, we could make discoverable\r\nservers use a specific category and then indicate the url through a property\r\nin `data`. This might depend on mDNS capabilities since we want it to be\r\nefficient to query for all servers with a user UI.*\r\n\r\n# Methods\r\n\r\n### navigator.publishServer\r\n\r\n```\r\npromise = navigator.publishServer(name, {...options...});\r\n```\r\n\r\nImmediately returns a new `Promise` object. The user agent asynchronously\r\nbegins the process of establishing a published service under the given\r\nname. The user agent SHOULD prompt the user before advertising a service\r\nfrom a web page allowing the user to prevent the page from advertising\r\nservices to nearby clients.\r\n\r\nIf the user declined the publishing or an error occurs, the `Promise`\r\nis rejected.\r\n\r\nIf the publishing is successful, the `Promise` is resolved with a\r\n`FlyWebPublishedServer` object:\r\n\r\n```language-webidl\r\ninterface FlyWebPublishedServer : EventTarget {\r\n  readonly attribute DOMString name;\r\n  readonly attribute DOMString? uiUrl;\r\n\r\n  void close();\r\n\r\n  attribute EventHandler onclose;\r\n  attribute EventHandler onfetch;\r\n  attribute EventHandler onwebsocket;\r\n};\r\n```\r\n\r\n# Attributes\r\n\r\n### publishedServer.name\r\n\r\nThe display name the server is published under.\r\n\r\n### publishedServer.uiUrl\r\n\r\nThe URL to the published server that clients should connect to.\r\n\r\n# Events\r\n\r\n### onclose\r\n\r\nCalled when the published server is closed, for example because the\r\n`close()` method is called on the `FlyWebPublishedServer` object.\r\n\r\n### onfetch\r\n\r\nCalled when a client of the published server sends an HTTP request.\r\nThe event type is 'FlyWebFetchEvent':\r\n\r\n```language-webidl\r\ninterface FlyWebFetchEvent : Event {\r\n  [SameObject] readonly attribute Request request;\r\n\r\n  [Throws]\r\n  void respondWith(Promise<Response> r);\r\n};\r\n```\r\n\r\nThe `request` attribute holds a DOM `Request` object describing the\r\ndetails of the HTTP request.\r\n\r\nThe `respondWith` method on the event can accept a `Promise` for\r\nresolving a `Response` object to service the HTTP request.\r\n\r\n### onwebsocket\r\n\r\nCalled when a client of the published server establishes a new WebSocket\r\nconnection request. The event type is 'FlyWebWebSocketEvent':\r\n\r\n```language-webidl\r\ninterface FlyWebWebSocketEvent : Event {\r\n  [SameObject] readonly attribute Request request;\r\n\r\n  [Throws]\r\n  WebSocket accept(optional DOMString protocol);\r\n\r\n  [Throws]\r\n  void respondWith(Promise<Response> r);\r\n};\r\n```\r\n\r\nThe `request` attribute holds a DOM `Request` object describing the\r\ndetails of the WebSocket request.\r\n\r\nThe `accept` method on the event can be used to accept the WebSocket\r\nrequest. It immediately returns a WebSocket instance which can be used\r\nto communicate with the client.\r\n\r\nThe `respondWith` method on the event can accept a `Promise` for\r\nresolving a `Response` object to service the WebSocket request.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}